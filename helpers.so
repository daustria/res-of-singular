LIB "general.lib";

/*
polynomials: a list of polynomials

Returns the polynomial in the list with a monomial of minimum total degree. 

-If there are multiple choices, a
'greatest' polynomial is chosen where the ordering comes from the active basering.

-If the list is empty, returns the zero polynomial poly(0).

Example:

ring A = 0,(x,y),lp; // 'lp' specifies the lexicographical monomial ordering

poly f1 = x3y2 + 7y3 - 3x3 - 12xy;
poly f2 = y5 + 9x2 - xy;
poly f3 = y5 + 11x3 + y2;
poly f4 = x4y - y3 - x;
poly f5 = xy4 + 2x2 + 9y;

list l = f1,f2,f3,f5;

smallest_total_degree(l);
>> x4y - y3 - x;
*/
proc smallest_total_degree(list polynomials)
{
	if(size(polynomials == 0))
	{
		return poly(0);
	}

	list candidates;
	int min_so_far = mindeg(polynomials[1]);

	int len = size(polynomials);

	for(int i = 1; i <= len; i++)
	{
		int current_mindeg = mindeg(polynomials[i]);

		if(current_mindeg <= min_so_far)
		{
			candidates = insert(candidates, polynomials[i]);
			min_so_far = current_mindeg;
		}	
	}

	sort(candidates);
	return(candidates[1]);
}

/*

Computes the first 0 to d-1 order partial derivatives of f and returns a polynomial from that collection which has multiplicity 1 at the origin.
If none exist, returns poly(0).

Requires:
	f is a non-zero polynomial that has degree d > 0.
	A basering is defined.

//example:
ring A = 0,(x,y,z),lp;
poly f = x2 + y2;
hypersurface_of_max_contact(f, 2);
>>  2x

*/
proc hypersurface_of_max_contact(poly f, int d)
{
	// we want f to have at least degree 0, so just terminate with poly(0) otherwise.
	if (mindeg(f) < d)
	{
		return(poly(0));
	}


	//to_process is a list of nodes to process.
	//each item is a node containing a partial derivative of the polynomial and its order.
	//only process up to order d-1.
	list to_process = list(list(f, 0));

	while(size(to_process) > 0)
	{
		list current_node = to_process[1];
		poly current_derivative = current_node[1];
		int current_order = current_node[2];

		to_process = delete(to_process, 1);

		if(mindeg(current_derivative) == 1)
		{
			return(current_derivative);
		}	
		else
		{
			//add all partial derivatives of the current polynomial to the end of the 
			//processing list, except those partial derivatives of order d or more.
			if(current_order < d)
			{
				for(int j = 1; j <= nvars(basering); j++)
				{
					poly g = diff(current_derivative, var(j));
					if(mindeg(g) > 0)
					{
						to_process = insert(to_process, list(g, current_order + 1), size(to_process));
					}
				}
			}
		}
	}	

	return(poly(0));
}
