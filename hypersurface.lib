////////////////////////////////////////////////////////////////
info="
LIBRARY:   hypersurface.lib  
AUTHOR:    Dominic Austria, email: dgaustri@uwaterloo.ca

";
////////////////////////////////////////////////////////////////

static proc mod_init()
{
	LIB "general.lib";
}

/*
polynomials: a list of polynomials

Returns the polynomial in the list with a monomial of minimum total degree. 

-If there are multiple choices, a
'greatest' polynomial is chosen where the ordering comes from the active basering.

-If the list is empty, returns the zero polynomial poly(0).
*/
proc smallest_total_degree_polynomial(list polynomials)
{
	if(size(polynomials) == 0)
	{
		return poly(0);
	}

	list candidates;

	int min_so_far = mindeg(polynomials[1]);

	int len = size(polynomials);

	for(int i = 1; i <= len; i++)
	{
		int current_mindeg = mindeg(polynomials[i]);

		if(current_mindeg <= min_so_far)
		{
			candidates = insert(candidates, polynomials[i]);
			min_so_far = current_mindeg;
		}	
	}

	candidates = sort(candidates);
	return(candidates[1][1]);
}
example
{
	ring A = 0,(x,y),lp;

	poly f1 = x3y2 + 7y3 - 3x3 - 12xy;
	poly f2 = y5 + 9x2 - xy;
	poly f3 = y5 + 11x3 + y2;
	poly f4 = x4y - y3 - x;
	poly f5 = xy4 + 2x2 + 9y;

	list l = f1,f2,f3,f4,f5;

	smallest_total_degree_polynomial(l); // 2x2 + xy4 + 9y;
}

proc smallest_total_degree(list polynomials)
{
	return(mindeg(smallest_total_degree_polynomial(polynomials)));
}

// sort the ring variables x_i in order of the degree of f when expressed
// as a polynomial in x_i
static proc sort_ringvars(poly f)
{
	list degrees_of_f = list();

	for(int i = 1; i <= nvars(basering); i++)
	{
		matrix m = coef(f, var(i));
		int d = deg(m[1,1]);

		degrees_of_f = insert(degrees_of_f, d, size(degrees_of_f));
	}

	//now, degrees_of_f[i] is the degree of f as a polynomial in x_i
	// we produce the list of ring variables with the same ordering
	list permutation = sort(degrees_of_f);

	list sorted_ringvars = list();

	for(int i = 1; i <= nvars(basering); i++)
	{
		sorted_ringvars = insert(sorted_ringvars, var(permutation[2][i]), size(sorted_ringvars));
	}

	return(sorted_ringvars);
}


// returns the degree of f as a polynomial in the ring variable z
static proc degree_in(poly f, poly z)
{
	matrix m = coef(f, z);
	return(deg(m[1,1]));
}

static proc hypersurface_max_contact_core(poly f, int current_order, int max_order)
{

	if(result != poly(0))
	{
		return();	
	}

	// maintain the print level
	printlevel = printlevel + current_order;

	if(current_order >= max_order)
	{
		return();
	}

	dbprint("hypersurface_max_contact_core | f:"+string(f) + " order: "+string(current_order) + " max_order: "+string(max_order));

	f = simplify(f, 1);

	if(mindeg(f) == 1)
	{
		if(rvar(f))
		{
			dbprint("hypersurface_max_contact_core | terminating with:"+string(f));
			result = f;
			return();
		}
	}

	ideal j = jacob(f); //all possible candidates

	j = simplify(j,1+2+4+8);

	for(int i = 1; i <= size(j); i++)
	{
		poly g = j[i];

		if(mindeg(g) > 0)
		{
			hypersurface_max_contact_core(g, current_order + 1, max_order);
		}
	}

}

/*
 * Computes the hypersurface of maximum contact of f at the origin, such that
 * the result is a coordinate variable.
 *
 * Requires:
 * 	-f is a non-zero polynomial that has degree d > 0.

*/
proc hypersurface_max_contact(poly f)
{
	//derivative ideal of order 1
	ideal derivative_ideal = jacob(f) + ideal(f);

	ideal previous_order_d_ideal = derivative_ideal;

	//sum the derivative ideals starting from 1
	for(int i = 2; i < mindeg(f); i++)
	{
		ideal derivative_ideal_order_i = 0;	

		//construct the first derivative ideal of the previous order, which consists of 
		//its generators and first partial derivatives
		for(int j = 1; j <= size(previous_order_d_ideal); j++)
		{
			ideal first_partials = jacob(previous_order_d_ideal[j]);
			derivative_ideal_order_i = derivative_ideal_order_i + first_partials;
		}

		derivative_ideal_order_i = derivative_ideal_order_i + previous_order_d_ideal;

		previous_order_d_ideal = derivative_ideal_order_i;

		previous_order_d_ideal = simplify(previous_order_d_ideal, 1+2+4+8);

		derivative_ideal = derivative_ideal + derivative_ideal_order_i;
		derivative_ideal = simplify(derivative_ideal, 1+2+4+8);

		dbprint(sprintf("hypersurface_max_contact | f:%s derivative_ideal:%s", f, derivative_ideal));
	}

	
	dbprint(sprintf("hypersurface_max_contact | f:%s + derivative_ideal:%s", f, derivative_ideal));

	//now find an element of order 1, which should exist
	for(int i = 1; i <= size(derivative_ideal); i++)
	{
		poly f = derivative_ideal[i];

		f = simplify(f, 1);
		if(rvar(f))
		{
			return(f);
		}
	}
	return(poly(0));

}
example
{
	ring A = 0,(x,y,z),lp;
	poly f = 2x3 + 3y2;
	hypersurface_max_contact(f); // y
}
