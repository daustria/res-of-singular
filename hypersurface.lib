////////////////////////////////////////////////////////////////
info="
LIBRARY:   hypersurface.lib  
AUTHOR:    Dominic Austria, email: dgaustri@uwaterloo.ca

";
////////////////////////////////////////////////////////////////

static proc mod_init()
{
	LIB "general.lib";
}

/*
polynomials: a list of polynomials

Returns the polynomial in the list with a monomial of minimum total degree. 

-If there are multiple choices, a
'greatest' polynomial is chosen where the ordering comes from the active basering.

-If the list is empty, returns the zero polynomial poly(0).
*/
proc smallest_total_degree_polynomial(list polynomials)
{
	if(size(polynomials) == 0)
	{
		return poly(0);
	}

	list candidates;

	int min_so_far = mindeg(polynomials[1]);

	int len = size(polynomials);

	for(int i = 1; i <= len; i++)
	{
		int current_mindeg = mindeg(polynomials[i]);

		if(current_mindeg <= min_so_far)
		{
			candidates = insert(candidates, polynomials[i]);
			min_so_far = current_mindeg;
		}	
	}

	sort(candidates);
	return(candidates[1]);
}
example
{
	ring A = 0,(x,y),lp;

	poly f1 = x3y2 + 7y3 - 3x3 - 12xy;
	poly f2 = y5 + 9x2 - xy;
	poly f3 = y5 + 11x3 + y2;
	poly f4 = x4y - y3 - x;
	poly f5 = xy4 + 2x2 + 9y;

	list l = f1,f2,f3,f4,f5;

	smallest_total_degree_polynomial(l); // 2x2 + xy4 + 9y;
}

proc smallest_total_degree(list polynomials)
{
	return mindeg(smallest_total_degree_polynomial(polynomials));
}


/*
 * TODO: Should I make this compute the derivatives until it returns
 * a suitable one that is also a coordinate variable??
 *
 * Computes the hypersurface of maximum contact of f at the origin, such that
 * the result is a coordinate variable.
 *
 * Requires:
 * 	-f is a non-zero polynomial that has degree d > 0.

*/
proc hypersurface_max_contact(poly f)
{
	int d = mindeg(f);

	// we want f to have at least degree 0, so just terminate with poly(0) otherwise.
	if (mindeg(f) < d)
	{
		return(poly(0));
	}

	dbprint("hypersurface_max_contact | processing :" + string(f));

	//consider the tree f and its partial derivatives of orders 0 to d-1.
	//to_process is a list of derivatives to process:
	//each item represents a node containing a partial derivative of the polynomial and its order.
	//only process up to order d-1.
	list to_process = list(list(f, 0));

	//breadth first search on the partial derivatives of f
	while(size(to_process) > 0)
	{
		list current_node = to_process[1];
		poly current_derivative = current_node[1];
		int current_order = current_node[2];

		dbprint("hypersurface_max_contact | current_derivative:"+string(current_derivative) + " current_order:"+string(current_order) + " polynomial:" + string(f));

		to_process = delete(to_process, 1);
		
		if(mindeg(current_derivative) == 1)
		{

			poly simplified = simplify(current_derivative, 1); // divide by the leading coefficient
			dbprint("hypersurface_max_contact | result is:" + string(simplified));

			if(rvar(simplified))
			{
				return(simplified);
			}

			dbprint("hypersurface_max_contact | " + string(simplified) + " is suitable, but not a ring variable. discarding.");
		}	

		//add all partial derivatives of the current polynomial to the start of the
		//processing list, except those partial derivatives of order d or more.
		if(current_order < d-1)
		{
			for(int j = 1; j <= nvars(basering); j++)
			{
				poly g = diff(current_derivative, var(j));
				if(mindeg(g) > 0)
				{
					to_process = insert(to_process, list(g, current_order + 1));
				}
			}
		}
	
	}	

	dbprint("hypersurface_max_contact | Error: could not find a hypersurface of max contact");
	return(poly(0));
}
example
{
	ring A = 0,(x,y,z),lp;
	poly f = 2x3 + 3y2;
	hypersurface_max_contact(f); // y
}
