////////////////////////////////////////////////////////////////
info="
LIBRARY:   hypersurface.lib  
AUTHOR:    Dominic Austria, email: dgaustri@uwaterloo.ca

";
////////////////////////////////////////////////////////////////

static proc mod_init()
{
	LIB "general.lib";
	LIB "zeroset.lib";
}

/*
polynomials: a list of polynomials

Returns the polynomial in the list with a monomial of minimum total degree. 

-If there are multiple choices, a
'greatest' polynomial is chosen where the ordering comes from the active basering.

-If the list is empty, returns the zero polynomial poly(0).
*/
proc smallest_total_degree_polynomial(list polynomials)
{
	if(size(polynomials) == 0)
	{
		return poly(0);
	}

	list candidates;

	int min_so_far = mindeg(polynomials[1]);

	int len = size(polynomials);

	for(int i = 1; i <= len; i++)
	{
		int current_mindeg = mindeg(polynomials[i]);

		if(current_mindeg <= min_so_far)
		{
			candidates = insert(candidates, polynomials[i]);
			min_so_far = current_mindeg;
		}	
	}

	candidates = sort(candidates);
	return(candidates[1][1]);
}
example
{
	ring A = 0,(x,y),lp;

	poly f1 = x3y2 + 7y3 - 3x3 - 12xy;
	poly f2 = y5 + 9x2 - xy;
	poly f3 = y5 + 11x3 + y2;
	poly f4 = x4y - y3 - x;
	poly f5 = xy4 + 2x2 + 9y;

	list l = f1,f2,f3,f4,f5;

	smallest_total_degree_polynomial(l); // 2x2 + xy4 + 9y;
}

proc smallest_total_degree(list polynomials)
{
	return(mindeg(smallest_total_degree_polynomial(polynomials)));
}

// returns the degree of f as a polynomial in the ring variable z
static proc degree_in(poly f, poly z)
{
	matrix m = coef(f, z);
	return(deg(m[1,1]));
}

/*
 * Computes the hypersurface of maximum contact of f at the origin, such that
 * the result is a coordinate variable.
 *
 * Requires:
 * 	-f is a non-zero polynomial that has degree d > 0.

*/
proc hypersurface_max_contact(poly f)
{
	//a partial derivative of f is a coordinate variable if and only if
	//it has degree 1 in a single variabe, and 0 everywhere else.
	
	//for each variable x_i of f, differentiate f with respect to x_i until it has degree 1 in x_i.
	//then , for each x_j , j != i, differentiate f with respect to x_j until f has degree 0 in x_j.
	for(int i = 1; i <= nvars(basering); i++)
	{
		//we only take derivatives of f up to its minimum degree
		int derivativeOrder = 0;
		int maxOrder = mindeg(f);

		//first, check that x_i actually is a variable of f
		poly r = remainder(f, var(i));

		if(r != poly(0))
		{
			i++;
			continue;
		}

		poly g = f;

		while(degree_in(g, var(i)) > 1)
		{
			g = diff(g, var(i));
			derivativeOrder++;
			g = simplify(g, 1);

		}

		for(int j = 1; j <= nvars(basering); j++)
		{
			if(j == i)
			{
				j++;
				continue;
			}

			while(degree_in(g, var(j)) > 0)
			{
				g = diff(g, var(j));
				derivativeOrder++;
				g = simplify(g, 1);
			}
		}	

		if(rvar(g))
		{
			//question: do we need to check the order of the derivative or is any fine?
			/*
			if(derivativeOrder < maxOrder)
			{
				return(g);
			}
			*/
			return(g);
		}
	}
	//zero polynomial in case no such hypersurface of max contact is found
	return(poly(0));
}
example
{
	ring A = 0,(x,y,z),lp;
	poly f = 2x3 + 3y2;
	hypersurface_max_contact(f); // y
}
