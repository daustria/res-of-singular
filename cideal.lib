////////////////////////////////////////////////////////////////
info="
LIBRARY:   cideal.lib  
AUTHOR:    Dominic Austria, email: dgaustri@uwaterloo.ca

";
////////////////////////////////////////////////////////////////
static proc mod_init()
{
	newstruct("coeff_ideal", "ideal I, int d");

	system("install", "coeff_ideal", "+", add_coeff_ideal, 2); 
	system("install", "coeff_ideal", "print", pretty_print_coeff_ideal, 1);
	system("install", "coeff_ideal", "=", make_coeff_ideal, 1);
}

proc make_coeff_ideal(ideal I, int d)
{
	coeff_ideal J;
	J.I = I;
	J.d = d;
	return(J);
}

proc pretty_print_coeff_ideal(coeff_ideal J)
{
	"((" + string(J.I) + "), " + string(J.d) + ")"
}

// Returns the coefficient ideal that represents the sum of the coefficient ideals L and R.
proc add_coeff_ideal(coeff_ideal L, coeff_ideal R)
{
	coeff_ideal K = ideal(L.I^R.d + R.I^L.d), L.d * R.d;
	return(K);
}
example
{
	ring R = (0.complex),(x,y,z),dp;
	coeff_ideal J;
	J.I = ideal(x2+y2);
	J.d = 2;

	J+J; //((x4+2x2y2+y4), 4)
}

/*
This processes a certain kind of coefficient ideals for the algorithm described for computing the centre of blowup.

requires:
	-The ideal in the coefficient ideal J, namely J.I, is a non-zero principal ideal. J.I = (f) for a single non-zero polynomial f.
	-The degree of J, J.d, is the order of vanishing of f at the origin.
	-hypersurface_variable is just a coordinate variable, say x.
	-The generator f can be expressed as x^d + (c_(d-2))x^(d-2) + ... + c_1 x + c_0, where the c_i's are polynomials in the remaining ring variables

returns:
	0 if failed. Otherwise, the coefficient ideal required for the algorithm that computes the centre of blowup.
	
*/ 
proc process_coeff_ideal_principal(coeff_ideal J, poly hypersurface_variable)
{
	poly generator = J.I[1]; // we have that J has exactly one non-zero generator
	int d = J.d;

	matrix m = coef(generator, hypersurface_variable);

	// check that the generator f can be expressed 
	// in the form x^d + (c_(d-2))x^(d-2) + ... + c_1 x + c_0
	poly highest = m[1][1];
	poly second_highest = m[1][2];

	if(m[1][1] != hypersurface_variable^d)
	{
		return(0);
	}


	if(m[1][2] == hypersurface_variable^(d-1) && m[2][2] != 0)
	{
		// this change of variables is so that the coefficient of the hypersurface_variable^(d-1) 
		// the generator polynomial, namely c_(d-1), is 0.
		
		generator = subst(generator, hypersurface_variable, hypersurface_variable - (m[2][2]/d));
		m = coef(generator, hypersurface_variable);
	}

	dbprint(m);

	coeff_ideal out;
	out.I = ideal(0);
	out.d = 1;

	int num_terms = size(m) div 2;

	// start from 2, according to the algorithm.
	for(int i = 2; i <= num_terms; i++)
	{
		coeff_ideal K;

		dbprint("term : " + string(m[1,i]));
		dbprint("coefficient of the term : " + string(m[2,i]));

		K.I = ideal(m[2,i]);
		K.d = J.d - deg(m[1,i]);

		// add the marked ideal to the output
		out = out + K;

		dbprint("marked ideal to add is : ");
		dbprint(K);
		dbprint("marked ideal is now : ");
		dbprint(out);
	}

	return(out);
}
example
{
	ring R = 0,(x,y,z),dp;
	coeff_ideal J = ideal(z3-x2yz-x4), 3;
	process_coeff_ideal_principal(J); // ((-x6y3,x8), 6)
}

//same as process_coeff_ideal_principal, except that the ideal in J does not necessarily have to be principal.
proc process_coeff_ideal(coeff_ideal J, poly hypersurface_variable)
{
	coeff_ideal out = ideal(0), 1;

	for(int i = 1; i <= size(J); i++)
	{
		out = out + process_coeff_ideal_principal(J[i]);
	}

	return out
}


