////////////////////////////////////////////////////////////////
info="
LIBRARY:   cideal.lib  
AUTHOR:    Dominic Austria, email: dgaustri@uwaterloo.ca

";
////////////////////////////////////////////////////////////////
static proc mod_init()
{
	LIB "hypersurface.lib";

	newstruct("coeff_ideal", "ideal I, int d");

	system("install", "coeff_ideal", "+", add_coeff_ideal, 2); 
	system("install", "coeff_ideal", "print", pretty_print_coeff_ideal, 1);
	system("install", "coeff_ideal", "=", make_coeff_ideal, 1);
	system("install", "coeff_ideal", "string", string_coeff_ideal, 1);
}

proc make_coeff_ideal(ideal I, int d)
{
	coeff_ideal J;
	J.I = I;
	J.d = d;
	return(J);
}

proc string_coeff_ideal(coeff_ideal J)
{
	return("((" + string(J.I) + "), " + string(J.d) + ")");
}

proc pretty_print_coeff_ideal(coeff_ideal J)
{
	"((" + string(J.I) + "), " + string(J.d) + ")";
}

proc add_coeff_ideal(coeff_ideal L, coeff_ideal R)
{
	coeff_ideal K = ideal(L.I^R.d + R.I^L.d), L.d * R.d;
	return(K);
}
example
{
	ring R = (0,complex),(x,y,z),dp;
	coeff_ideal J;
	J.I = ideal(x2+y2);
	J.d = 2;

	J+J; // ((x^4+2*x^2*y^2+y^4), 4)
}


// let z be the hypersurface_variable, and let e denote the degree of f as
// a polynomial in z.
//
// this helper function returns the polynomial by taking 
// f and removing all of its all monomial terms with degree greater 
// than d (as a z- polynomial) :
//
// f = z^d + c_(d-1)z^(d-1) + ... + c_1 z + c_0
//
// and then, if c_(d-1) is non-zero, make the substitution z = z - (c_(d-1) / d)
// to remove the c_(d-1) term.
// 
// this could be inefficient, as we process the terms of f linearly.
static proc format_polynomial(poly f, poly hypersurface_variable, int d)
{

	dbprint("Formatting polynomial : " + string(f));
	dbprint("Hypersurface variable : " + string(hypersurface_variable));
	dbprint("Degree : " + string(d));

	poly z = hypersurface_variable; //shorten the name a little

	matrix m = coef(f, z);
	poly g = 0;

	int num_terms = size(m) div 2;

	int has_d_min_1_term = 0;
	poly c_d_min_1 = 0;

	for(int i = 1; i <= num_terms; i++)
	{
		int term_deg = deg(m[1,i]);
		poly coefficient = m[2,i];

		if(term_deg == d-1)
		{
			has_d_minus_1_term = 1;
			c_d_min_1 = coefficient;
		}

		if(term_deg == d && coefficient != poly(0))
		{
			dbprint("Coefficient of c^d is not 1");
		}

		if(term_deg > d)
		{
			continue;
		}
		else
		{
			g = g + coefficient * m[1,i];
		}
	}

	if(has_d_min_1_term)
	{
		// this change of variables gets rid of the c_(d-1) term
		g = subst(g, z, z - c_d_min_1 / d);
	}

	dbprint("Polynomial formatting result is : " + string(g));
	return(g);

}

//helper function for process_coeff_ideal
static proc process_coeff_ideal_principal(coeff_ideal J, poly hypersurface_variable)
{
	poly generator = J.I[1]; // we assume J has exactly one non-zero generator

	poly f = format_polynomial(generator, hypersurface_variable, J.d);

	matrix m = coef(f, hypersurface_variable);

	dbprint(m);

	// now, for each coefficient, we sum all coefficient ideals.
	coeff_ideal out = ideal(0), 1;

	int num_terms = size(m) div 2;

	for(int i = 1; i <= num_terms; i++)
	{
		int term_deg = deg(m[1,i]);

		dbprint("term : " + string(m[1,i]));
		dbprint("coefficient of the term : " + string(m[2,i]));

		if (term_deg == J.d)
		{
			dbprint("Skipping the d-th term");
			//need the i++ before continue in Singular, not like C.
			i++;
			continue;
		}

		coeff_ideal K;

		K.I = ideal(m[2,i]);
		K.d = J.d - deg(m[1,i]);

		out = out + K;

		dbprint("marked ideal to add is : " + string(K));
		dbprint("resulting marked ideal is now : " + string(out));
	}

	return(out);
}

/*
This processes a certain kind of coefficient ideals for the algorithm described for computing the centre of blowup.

requires:
	-hypersurface_variable is just a coordinate variable, say z.
	-Label the ideal J.I as (f_1,...,f_m). Then z = 0 is the hypersurface of max contact of J.I
	-The generator f can be expressed as z^d + (c_(d-2))z^(d-2) + ... + c_1 z + c_0, where the c_i's are polynomials in the remaining ring variables

returns:
	0 if failed. Otherwise, the coefficient ideal required for the algorithm that computes the centre of blowup.
	
*/ 
//TODO: needs some more tests too.
proc process_coeff_ideal(coeff_ideal J, poly hypersurface_variable)
{
	coeff_ideal out = ideal(0), 1;

	for(int i = 1; i <= size(J.I); i++)
	{
		coeff_ideal K = J.I[i], J.d;
		dbprint("Processing the principal coefficient ideal : " + string(K));
		coeff_ideal processed = process_coeff_ideal_principal(K, hypersurface_variable);
		dbprint("After processing, result is :" + string(processed));
		out = out + processed;
	}

	return(out);
}
example
{
	ring R = 0,(x,y,z),dp;
	// coeff_ideal J = ideal(z3-x2yz-x4), 3;
	coeff_ideal J;
	J.I = ideal(z3-x2yz-x4);
	J.d = 3;
	process_coeff_ideal(J, z); // ((-x6y3,x8), 6)
}

//assume I is non-zero
//TODO: needs tests
proc compute_invariant_0(ideal I)
{
	list generators = I[1..size(I)]; //the list with f_i, where I = (f_1,...,f_m)
	poly smallest_deg = smallest_total_degree_polynomial(generators);

	poly hypersurface_var = hypersurface_max_contact(smallest_deg);

	// order of vanishing of f_1,...,f_m at the origin corresponds to the f_i with smallest minimum degree
	int d = mindeg(smallest_deg);

	list invariant = d,0;

	coeff_ideal J = I, d;

	// terminate when J has the zero ideal
	while(size(J.I) > 0)
	{
		dbprint("Current coefficient ideal is : " + string(J));

		dbprint("Invariant is : " + string(invariant));

		coeff_ideal res = process_coeff_ideal(J, hypersurface_var);

		I = res.I;
		d = res.d;

		dbprint("After processing, coefficient ideal is : " + string(res));

		if(size(I) == 0)
		{
			break;
		}

		generators = I[1..size(I)];

		smallest_deg = smallest_total_degree_polynomial(generators);
		int e = mindeg(smallest_deg);

		invariant = invariant + list(number(e) / number(d), 0);

		//update the hypersurface of max contact
		hypersurface_var = hypersurface_max_contact(smallest_deg);

		res.d = e;
		//update the coefficient ideal
		J = res;
	}

	// use -1 to denote infinity
	return(invariant + list(-1));
}
example
{
	ideal I = z3 - x2yz - x4;
	list l = compute_invariant_0(I);
	string(l);
}
