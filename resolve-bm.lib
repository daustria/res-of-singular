////////////////////////////////////////////////////////////////
info="
LIBRARY:   resolve-bm.lib
AUTHOR:    Dominic Austria, email: dgaustri@uwaterloo.ca

";
////////////////////////////////////////////////////////////////

LIB "cideal.lib";

static proc mod_init()
{

	//invariant_data will be the data we need to do the resolution of singularities algorithm
	//after computing the invariant.
	newstruct("invariant_data", "list invariant, list hypersurfaces");

	system("install", "invariant_data", "string", string_invariant_data, 1);
	system("install", "invariant_data", "print", pretty_print_invariant_data, 1);
	system("install", "invariant_data", "=", make_invariant_data, 1);
}

proc string_invariant_data(invariant_data data)
{
	string out = "invariant:"+string(invariant)+" hypersurfaces"+string(hypersurfaces);
	return(out);
}

proc pretty_print_invariant_data(invariant_data data)
{
	print(string(data));
}

proc make_invariant_data(list invariant, list hypersurfaces)
{
	invariant_data data;
	data.invariant = invariant;
	data.hypersurfaces = hypersurfaces;
	return(data);
}


// let z be the hypersurface_variable, and let e denote the degree of f as
// a polynomial in z.
//
// this helper function returns the polynomial by taking 
// f and removing all of its all monomial terms with degree greater 
// than d (as a z- polynomial) :
//
// f = z^d + c_(d-1)z^(d-1) + ... + c_1 z + c_0
//
// and then, if c_(d-1) is non-zero, make the substitution z = z - (c_(d-1) / d)
// to remove the c_(d-1) term.
// 
// this could be inefficient, as we process the terms of f linearly.
static proc format_polynomial(poly f, poly hypersurface_variable, int d)
{

	dbprint("format_polynomial | f: " + string(f) + " hypersurface_of_max_contact:" + string(hypersurface_variable) + " d:" + string(d));

	poly z = hypersurface_variable; //shorten the name a little

	matrix m = coef(f, z);

	poly g = 0;

	int num_terms = size(m) div 2;

	int has_d_min_1_term = 0;
	poly c_d_min_1 = 0;

	for(int i = 1; i <= num_terms; i++)
	{
		int term_deg = deg(m[1,i]);
		poly coefficient = m[2,i];

		if(term_deg == d-1)
		{
			has_d_min_1_term = 1;
			c_d_min_1 = coefficient;
		}

		if(term_deg == d && coefficient != poly(1))
		{
			dbprint("format_polynomial | warning: coefficient of " + string(hypersurface_variable) + "^" + string(d) + " is not 1");
		}

		if(term_deg > d)
		{
			i++;
			continue;
		}
		else
		{
			g = g + coefficient * m[1,i];
		}
	}

	if(has_d_min_1_term)
	{
		// this change of variables gets rid of the c_(d-1) term
		poly s = z - c_d_min_1 / d;
		dbprint("format_polynomial | substituting " + string(z) + " with " + string(s));
		g = subst(g, z, s);
	}

	//divide by leading coefficient if it is a unit
	g = simplify(g, 1);

	dbprint("format_polynomial | result is :" + string(g));

	return(g);
}

//helper function for process_coeff_ideal
static proc process_coeff_ideal_principal(coeff_ideal J, poly hypersurface_variable)
{
	poly generator = J.I[1]; // we assume J has exactly one non-zero generator

	poly f = format_polynomial(generator, hypersurface_variable, J.d);

	matrix m = coef(f, hypersurface_variable);
	
	dbprint("process_coeff_ideal_principal | " + string(f) + " as a polynomial in " + string(hypersurface_variable) + ":");
	dbprint(m);

	// now, for each coefficient, we sum all coefficient ideals.
	coeff_ideal out = ideal(0), 1;

	int num_terms = size(m) div 2;

	for(int i = 1; i <= num_terms; i++)
	{
		int term_deg = deg(m[1,i]);
		if (term_deg == J.d)
		{
			//need the i++ before continue in Singular, not like C.
			i++;
			continue;
		}

		coeff_ideal K;

		K.I = ideal(m[2,i]);
		K.d = J.d - deg(m[1,i]);

		string term_str = "(" + string(m[2,i]) + ")" + string(hypersurface_variable) + "^" + string(term_deg);
		dbprint("process_coeff_ideal_principal | term: " + term_str + " ideal:" + string(K));

		out = out + K;

	}

	return(out);
}

/*
This processes a certain kind of coefficient ideals for the algorithm described for computing the centre of blowup.

requires:
	-hypersurface_variable is just a coordinate variable, say z.
	-Label the ideal J.I as (f_1,...,f_m). Then z = 0 is the hypersurface of max contact of J.I
	-The generator f can be expressed as z^d + (c_(d-2))z^(d-2) + ... + c_1 z + c_0, where the c_i's are polynomials in the remaining ring variables

returns:
	0 if failed. Otherwise, the coefficient ideal required for the algorithm that computes the centre of blowup.
	
*/ 
proc process_coeff_ideal(coeff_ideal J, poly hypersurface_variable)
{
	coeff_ideal out = ideal(0), 1;

	for(int i = 1; i <= size(J.I); i++)
	{
		coeff_ideal K = J.I[i], J.d;
		dbprint("process_coeff_ideal | processing ideal: " + string(K));
		coeff_ideal processed = process_coeff_ideal_principal(K, hypersurface_variable);
		dbprint("process_coeff_ideal | result is :" + string(processed));
		out = out + processed;
	}

	dbprint("process_coeff_ideal | final result is :" + string(out));
	return(out);
}
example
{
	ring R = 0,(x,y,z),dp;
	// coeff_ideal J = ideal(z3-x2yz-x4), 3;
	coeff_ideal J;
	J.I = ideal(z3-x2yz-x4);
	J.d = 3;
	process_coeff_ideal(J, z); // ((-x6y3,x8), 6)
}

//assume I is non-zero
//TODO: needs tests
proc compute_invariant_0(ideal I)
{
	list generators = I[1..size(I)]; //the list with f_i, where I = (f_1,...,f_m)
	poly smallest_deg = smallest_total_degree_polynomial(generators);

	poly hypersurface_var = hypersurface_max_contact(smallest_deg);

	if(!rvar(hypersurface_var))
	{
		ERROR("compute_invariant_0 | " + string(hypersurface_var) + " is not a ring variable");
	}

	// order of vanishing of f_1,...,f_m at the origin corresponds to the f_i with smallest minimum degree
	int d = mindeg(smallest_deg);

	list invariant = d,0;

	coeff_ideal J = I, d;

	// terminate when J has the zero ideal
	while(size(J.I) > 0)
	{
		dbprint("compute_invariant_0 | ideal:" + string(J) + " hypersurface of max contact:" + string(hypersurface_var) + " invariant:" + string(invariant));

		coeff_ideal res = process_coeff_ideal(J, hypersurface_var);

		I = res.I;
		d = res.d;

		if(size(I) == 0)
		{
			break;
		}

		generators = I[1..size(I)];

		smallest_deg = smallest_total_degree_polynomial(generators);
		int e = mindeg(smallest_deg);

		invariant = invariant + list(number(e) / number(d), 0);

		//update the hypersurface of max contact
		hypersurface_var = hypersurface_max_contact(smallest_deg);

		res.d = e;
		//update the coefficient ideal
		J = res;
	}

	// use -1 to denote infinity
	return(invariant + list(-1));
}
example
{
	ideal I = z3 - x2yz - x4;
	list l = compute_invariant_0(I);
	string(l);
}
